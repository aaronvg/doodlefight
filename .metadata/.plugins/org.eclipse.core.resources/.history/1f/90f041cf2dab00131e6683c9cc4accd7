package entities;

import java.util.ArrayList;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;

/**
 * This class controls all input to the game. It also converts drawings to box2D
 * objects and manages drawn paths.
 * 
 * @author Aaron
 * 
 */
public class DrawingManager {
	ArrayList<Vector2> currPoints;
	ArrayList<Line> paths;
	ShapeRenderer shaper;
	ArrayList<Vector2> tmp;
	boolean newPath;

	public DrawingManager() {
		newPath = true;
		currPoints = new ArrayList<Vector2>();
		paths = new ArrayList<Line>();
		shaper = new ShapeRenderer();
		shaper.setColor(Color.BLACK);

	}

	public void update(GameCamera cam, SpriteBatch batch) {
		if (Gdx.input.isTouched()) {
			// Start drawing path.
			Vector3 point = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
			cam.unproject(point);
			currPoints.add(new Vector2(point.x, point.y));
		} else {
			// if we were drawing a path, save it now into our buffer.
			if(currPoints.size() > 0) {
				Line l = new Line(new ArrayList<Vector2>(currPoints));
				paths.add(l);
				currPoints.clear();
			}
		}

		shaper.setProjectionMatrix(cam.combined);
		
		// Draw the current line (realtime drawing)
		shaper.begin(ShapeType.Line);
		for(int i = 0; i < currPoints.size() - 1; i++) {
			
			shaper.line(currPoints.get(i), currPoints.get(i + 1));
			
		}
		shaper.end();
		
		
		// Draw all previous lines.
		for (int i = 0; i < paths.size(); i++) {
			shaper.begin(ShapeType.Line);
			ArrayList<Vector2> points = paths.get(i).points;
			for(int j = 0; j < points.size() - 1; j++) {
				shaper.line(points.get(j), points.get(j+1));
				
			}
			
			shaper.end();
		}
		

	}
	public static int iterations = 2;
	public static float simplifyTolerance = 35f;
	
	// https://github.com/mattdesl/lwjgl-basics/wiki/LibGDX-Finger-Swipe
	public static void simplify(ArrayList<Vector2> points, float sqTolerance, ArrayList<Vector2> out) {
	    int len = points.size();

	    Vector2 point = new Vector2();
	    Vector2 prevPoint = points.get(0);

	    out.clear();
	    out.add(prevPoint);

	    for (int i = 1; i < len; i++) {
	        point = points.get(i);
	        if (distSq(point, prevPoint) > sqTolerance) {
	            out.add(point);
	            prevPoint = point;
	        }
	    }
	    if (!prevPoint.equals(point)) {
	        out.add(point);
	    }
	}

	public static float distSq(Vector2 p1, Vector2 p2) {
	    float dx = p1.x - p2.x, dy = p1.y - p2.y;
	    return dx * dx + dy * dy;
	}
	
	
	
	public static void smooth(ArrayList<Vector2> input, ArrayList<Vector2> output) {
	    //expected size
	    output.clear();
	    output.ensureCapacity(input.size()*2);

	    //first element
	    output.add(input.get(0));
	    //average elements
	    for (int i=0; i<input.size()-1; i++) {
	        Vector2 p0 = input.get(i);
	        Vector2 p1 = input.get(i+1);

	        Vector2 Q = new Vector2(0.75f * p0.x + 0.25f * p1.x, 0.75f * p0.y + 0.25f * p1.y);
	        Vector2 R = new Vector2(0.25f * p0.x + 0.75f * p1.x, 0.25f * p0.y + 0.75f * p1.y);
	            output.add(Q);
	            output.add(R);
	    }

	    //last element
	    output.add(input.get(input.size()-1));
	}

	private class Line {
		public ArrayList<Vector2> points;

		public Line(ArrayList<Vector2> points) {
			this.points = points;

		}
		
		public int size() {
			return points.size();
		}
	}

}
